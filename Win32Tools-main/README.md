# Win32Tools

## Как с этим работать?

### ВАЖНО!
Для корректной работы **запускайте программу через командную строку с правами администратора**

### Зависимости
Проект использует библиотеки `psutil` и `pefile`.
Все зависимости устанавливаются автоматически, при запуске модулей `dscan_tool.py` и `sscan_tool.py`

### Для выполнения запуска .dll файлов необходимо:

1. Скачать файлы из репозитория
2. Запустить `main.py` с правами Администратора в командной строке
3. В открывшемся окне выбрать вкладку `.dll -> Run .dll calls`
4. Последовательно выбрать путь до `.dll` файла, после - до файла с вызовами формата `.json`
5. Ответы вызовов выбранной библиотеки можно увидеть в окне приложения

### Для вызова служб необходимо:

1. Скачать файлы из репозитория
2. Запустить `main.py` с правами Администратора в командной строке
3. В открывшемся окне выбрать вкладку `Win32 services -> Run service calls`
5. Введите имя службы и выберите путь до файла с вызовами формата `.json`
5. Ответы вызовов выбранной службы можно увидеть в окне приложения

### Файл вызовов

Для выполнения вызовов выбранных компонент, необходимо составить `файл вызовов` указанных форматов.

*Ниже преведены общие структуры для файлов вызовов .dll и служб.*

#### Структура файла вызовов для .dll компонент (dll_example.json):

```
{
	"function_name": {
		"args": null (or [] if args exists),
		"restype": C type
		"iters": <int>
	},
	...
}
```
где `function_name` - имя функции из библиотеки, `args` - набор аргументов функции, `restype` - тип возвращаемых данных C++, `iters` - количество итераций выполнения функции

#### Структура файла вызовов для служб (service_example.json):

```
...IN PROGRESS...
```

### Поддерживаемые C types

 `char*` - возвращаемый тип данных `== string/char*/const char*`  
 `void*` - возвращаемый тип данных `void`  
 `_Bool` - для `bool` типа данных  
 `int` - все остальные типы данных возвращаются в формате `int` 

### Updates

#### Minor 0.3 update 19.02.25:
- Функции тестового модуля c_tools теперь запускаются через потоковую обертку модуля t_tools[threading]
- t_tools.py - новый модуль с модифицированным классом Thread, для запуска и получения ответа потока выполнения

#### Major 1.0 update 19.02.25:
- Новый модуль `shedule.py`: запуск и исполнение модуля `c_tools.py` через класс `Popen` библиотеки `subprocess`
	```
	...
	p = subprocess.Popen(["python", tool, path, case], stdout=subprocess.PIPE)
	...
	```
- Обновленные зависимости: вызов теста `.dll` библиотек по схеме `gui -> t_tools.runThread(shedule.runProcess, args=*args)`
	```
	from t_tools import runThread
	from shedule import runProcess
	...
	dllFuncTestResponse = runThread(runProcess, args=[self.dll_path, self.case_path])
	...
	```
- Isolated Mode: все тесты запускаются в изолированном потоке, а результаты записываются в `sys.stdout`

#### Minor 1.1.2(2225) update 20.02.2025:
- Исправлен баг: `c_tool.py not found` - установлены относительные пути поиска исполняемых скриптов

#### Minor 1.2.0(2225)a 20.02.2025
- Доработана функция `ServiceFuncTest` - на данный момент функция получает сведения о .dll компонентах службы и выгружает их из тест-кейсов. В ответ возвращается список найденных .dll внутри `memory_maps` процесса

#### Major 1.3 update 24.02.25
- Переработан GUI (изменено расположение пунктов меню и их функционал)
- `.dll -> Run .dll calls` по прежнему вызывает срабатывание `runProcess`, но с новым шаблоном - `dll_tool.py`
- Шаблон `p_tools.py` переименован в `sscan_tool.py` и применяется для сканирования служб
- Новый инструмент `Analysis` - позволяет просканировать выбранные библиотеки или службы.

#### Minor 1.3.1 update 24.02.25
- Добавлены функции `Entry scan` и `Service scan`
- `Entry scan` - поиск точек входа в `PE` файлы
- `Service scan` - поиск исполняемых файлов и библиотек с зависимостями
